## 技術備忘錄：Docker 環境中 Python 虛擬環境 (`.venv`) 相關問題排查與解決方案

**日期:** 2025年09月10日
**作者:** Gemini AI

### 1. 問題描述 (Problem Description)

在 `Docker` 化 `Python` 專案（特別是 `Django` 應用）的開發環境中，當嘗試在容器內部執行 `Python` 命令（例如 `python manage.py check`）時，即使已確認套件已列在 `pyproject.toml` 或 `requirements.txt` 中，仍會遇到 `ModuleNotFoundError`（例如 `No module named 'django'` 或 `No module named 'dotenv'`）。

### 2. 根本原因分析 (Root Cause Analysis)

此類問題通常源於 `Docker` 的卷掛載機制、`.dockerignore` 配置、`Dockerfile` 建置流程，以及 `Docker` 命令執行方式之間的複雜交互作用。

*   **A. `docker-compose.yml` 卷掛載衝突 (Volume Mount Conflicts):
    *   **常見配置：** `volumes: - .:/app` (將主機專案目錄掛載到容器 `/app`)
    *   **潛在衝突：** 若 `docker-compose.yml` 中同時存在 `volumes: - /app/.venv` (為容器內的 `.venv` 創建匿名卷)，則此匿名卷會**遮蔽**主機掛載進來的 `.venv`，導致容器內部的 `.venv` 為空或不完整。
*   **B. `.dockerignore` 排除 `.venv` (Exclusion by `.dockerignore`):
    *   `.dockerignore` 檔案中若包含 `.venv`，則在 `Dockerfile` 的 `COPY` 指令執行時，`.venv` 目錄將不會被複製到 `Docker` 映像檔中。這在生產環境中是為了縮小映像檔大小，但在開發或特定建置流程中可能導致問題。
*   **C. `Dockerfile` 建置流程與 `COPY` 指令的細微差別 (`Dockerfile` Build Process & `COPY` Nuances):
    *   **虛擬環境建立：** `uv` 或 `pip` 建立的虛擬環境 (`.venv`) 結構，有時在 `Docker` 的 `COPY` 指令下表現不一致，可能導致 `.venv` 未被正確複製。
    *   **多階段建置 (`Multi-stage Build`)：** 在 `builder` 階段建立的 `.venv`，若未被最終階段正確地 `COPY --from=builder`，則最終映像檔將缺少必要的環境。
    *   **`COPY` 行為：** 廣泛的 `COPY . /app` 可能會覆寫或遺漏已在之前步驟中建立的 `.venv`。
*   **D. `docker compose exec`與 `docker compose run` 的執行環境差異 (Execution Environment Discrepancy):
    *   **`docker compose exec`：** 在運行中的容器內執行命令。其環境變數（特別是 `PATH`）可能受到容器啟動時 `CMD`/`ENTRYPOINT` 的影響，或在某些情況下對符號連結的解析不如預期，導致找不到可執行檔。
    *   **`docker compose run`：** 創建一個新的臨時容器來執行命令。它提供了一個更乾淨、更隔離的執行環境，通常能避免 `exec` 遇到的環境問題。

### 3. 排查步驟與解決方案 (Troubleshooting Steps & Solutions)

當遇到 `ModuleNotFoundError` 或 `.venv` 相關問題時，請依序執行以下排查步驟：

1.  **確認主機的 `.venv` 狀態：**
    *   **檢查：** 在主機的專案根目錄下，執行 `ls -l .venv/bin`，確認 `python`、`django-admin` 及其他套件的可執行檔是否存在。
    *   **解決方案：** 若不存在或不完整，請在主機上執行 `uv sync` 或 `pip install -r requirements.txt` 來更新主機的虛擬環境。
2.  **檢查 `docker-compose.yml` 的卷掛載配置：**
    *   **檢查：** 檢查 `bes-app` 服務下是否有 `volumes: - /app/.venv` 這一行。
    *   **解決方案：** 若有，請**移除**此行。這將確保容器使用主機掛載進來的 `.venv`。
    *   **操作：** 修改 `docker-compose.yml` 後，執行 `docker compose restart bes-app`。
3.  **檢查 `.dockerignore` 檔案：**
    *   **檢查：** 確認 `.dockerignore` 中是否包含 `.venv`。
    *   **解決方案：** 若 `Dockerfile` 意圖將 `.venv` 建置到映像檔中，請**移除** `.dockerignore` 中的 `.venv` 條目。
    *   **操作：** 修改 `.dockerignore` 後，執行 `docker compose build bes-app`。
4.  **優化 `Dockerfile` 的 `.venv` 處理邏輯：**
    *   **檢查：** 確保 `Dockerfile` 能可靠地建立和複製 `.venv`。
    *   **解決方案 (推薦的多階段建置模式)：**
        *   **`builder` 階段：**
            ```dockerfile
            FROM ghcr.io/astral-sh/uv:python3.12-bookworm-slim AS builder
            WORKDIR /app
            RUN python -m venv .venv # 明確建立虛擬環境
            RUN .venv/bin/pip install uv # 安裝 uv 到 venv 中
            # 使用 venv 中的 uv 安裝相依套件
            RUN --mount=type=cache,target=/root/.cache/uv \
                --mount=type=bind,source=uv.lock,target=uv.lock \
                --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
                .venv/bin/uv sync --frozen --no-install-project --no-dev
            ADD . /app # 複製應用程式碼
            RUN --mount=type=cache,target=/root/.cache/uv \
                .venv/bin/uv sync --frozen --no-dev # 再次同步確保所有套件安裝
            ```
        *   **最終映像檔階段：**
            ```dockerfile
            FROM python:3.12-slim-bookworm
            # 明確複製虛擬環境
            COPY --from=builder /app/.venv /app/.venv
            # 複製應用程式碼 (確保 .venv 不會被覆蓋)
            COPY --from=builder /app /app
            WORKDIR /app
            ENV PATH="/app/.venv/bin:$PATH" # 設定 PATH
            # ... 其他設定
            ```
    *   **操作：** 修改 `Dockerfile` 後，執行 `docker compose build bes-app`。
5.  **選擇正確的 `Docker` 命令執行方式進行驗證：**
    *   **檢查：** 若 `docker compose exec` 遇到 `ModuleNotFoundError` 或 `stat: no such file or directory`，即使路徑正確。
    *   **解決方案：** 改用 `docker compose run --rm bes-app /app/.venv/bin/python manage.py check` 進行驗證。
        *   `docker compose run` 會在一個乾淨的臨時容器中執行命令，能有效避免 `exec` 可能遇到的環境問題。
    *   **操作：** 執行驗證命令。

### 4. 關鍵教訓 (Key Takeaways)

*   **理解 `Docker` 卷掛載的行為：** 在開發環境中，`volumes` 掛載會讓容器直接使用主機的檔案系統。這意味著容器的 `Python` 環境可能**依賴於主機的 `.venv`**。
*   **明確 `.venv` 的來源：** 始終清楚您的容器是使用**主機掛載的 `.venv`** 還是**映像檔內建的 `.venv`**。
*   **`Dockerfile` 的精確性：** 在 `Dockerfile` 中，對於 `.venv` 的建立、安裝和複製，需要非常明確和精確的指令，避免隱式行為或廣泛的 `COPY` 導致問題。
*   **選擇正確的 `Docker` 命令：** `docker compose exec` 和 `docker compose run` 有不同的執行特性。在偵錯或驗證時，`docker compose run` 往往能提供更可靠的結果。
